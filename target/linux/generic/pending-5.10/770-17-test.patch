--- a/drivers/net/ppp/ppp_generic.c
+++ b/drivers/net/ppp/ppp_generic.c
@@ -1406,6 +1406,27 @@ ppp_get_stats64(struct net_device *dev,
 	stats64->rx_length_errors = dev->stats.rx_length_errors;
 }
 
+static int ppp_dev_fill_forward_path(struct net_device_path_ctx *ctx,
+				     struct net_device_path *path)
+{
+	struct ppp *ppp = netdev_priv(ctx->dev);
+	struct channel *pch;
+	struct ppp_channel *chan;
+
+	if (ppp->flags & SC_MULTILINK)
+		return -EOPNOTSUPP;
+
+	if (list_empty(&ppp->channels))
+		return -ENODEV;
+
+	pch = list_first_entry(&ppp->channels, struct channel, clist);
+	chan = pch->chan;
+	if (!chan->ops->fill_forward_path)
+		return -EOPNOTSUPP;
+
+	return chan->ops->fill_forward_path(chan, ctx, path);
+}
+
 static int ppp_dev_init(struct net_device *dev)
 {
 	struct ppp *ppp;
@@ -1456,6 +1477,7 @@ static const struct net_device_ops ppp_n
 	.ndo_start_xmit  = ppp_start_xmit,
 	.ndo_do_ioctl    = ppp_net_ioctl,
 	.ndo_get_stats64 = ppp_get_stats64,
+	.ndo_fill_forward_path	= ppp_dev_fill_forward_path,
 };
 
 static struct device_type ppp_type = {
--- a/drivers/net/ppp/pppoe.c
+++ b/drivers/net/ppp/pppoe.c
@@ -972,8 +972,29 @@ static int pppoe_xmit(struct ppp_channel
 	return __pppoe_xmit(sk, skb);
 }
 
+static int pppoe_fill_forward_path(struct ppp_channel *chan,
+				   struct net_device_path_ctx *ctx,
+				   struct net_device_path *path)
+{
+	struct sock *sk = (struct sock *)chan->private;
+	struct pppox_sock *po = pppox_sk(sk);
+	struct net_device *dev = po->pppoe_dev;
+
+	if (sock_flag(sk, SOCK_DEAD) ||
+	    !(sk->sk_state & PPPOX_CONNECTED) || !dev)
+		return -ENODEV;
+
+	path->type = DEV_PATH_PPPOE;
+	path->pppoe.sid = po->num;
+	path->dev = ctx->dev;
+	ctx->dev = dev;
+
+	return 0;
+}
+
 static const struct ppp_channel_ops pppoe_chan_ops = {
 	.start_xmit = pppoe_xmit,
+	.fill_forward_path = pppoe_fill_forward_path,
 };
 
 static int pppoe_recvmsg(struct socket *sock, struct msghdr *m,
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -841,6 +841,7 @@ enum net_device_path_type {
 	DEV_PATH_VLAN,
 	DEV_PATH_BRIDGE,
 	DEV_PATH_DSA,
+	DEV_PATH_PPPOE,
 };
 
 struct net_device_path {
@@ -865,6 +866,9 @@ struct net_device_path {
 			int port;
 			u16 proto;
 		} dsa;
+		struct {
+			__be16 sid;
+		} pppoe;
 	};
 };
 
--- a/include/linux/ppp_channel.h
+++ b/include/linux/ppp_channel.h
@@ -28,6 +28,10 @@ struct ppp_channel_ops {
 	int	(*start_xmit)(struct ppp_channel *, struct sk_buff *);
 	/* Handle an ioctl call that has come in via /dev/ppp. */
 	int	(*ioctl)(struct ppp_channel *, unsigned int, unsigned long);
+	/* Get the forwarding path to reach the real device from the HW destination address */
+	int	(*fill_forward_path)(struct ppp_channel *,
+				     struct net_device_path_ctx *,
+				     struct net_device_path *);
 };
 
 struct ppp_channel {
--- a/include/net/netfilter/nf_flow_table.h
+++ b/include/net/netfilter/nf_flow_table.h
@@ -119,6 +119,8 @@ struct flow_offload_tuple {
 	/* All members above are keys for lookups, see flow_offload_hash(). */
 	struct { }			__hash;
 
+	__be16				in_pppoe_sid;
+
 	struct {
 		u16			id;
 		__be16			proto;
@@ -181,6 +183,7 @@ struct nf_flow_route {
 		struct dst_entry		*dst;
 		struct {
 			u32			ifindex;
+			__be16			pppoe_sid;
 			u16			vid[NF_FLOW_TABLE_VLAN_MAX];
 			__be16			vproto[NF_FLOW_TABLE_VLAN_MAX];
 			struct {
--- a/net/netfilter/nf_flow_table_core.c
+++ b/net/netfilter/nf_flow_table_core.c
@@ -92,6 +92,7 @@ static int flow_offload_fill_route(struc
 	}
 
 	flow_tuple->iifidx = route->tuple[dir].in.ifindex;
+	flow_tuple->in_pppoe_sid = route->tuple[dir].in.pppoe_sid;
 	for (i = route->tuple[dir].in.num_vlans - 1; i >= 0; i--) {
 		flow_tuple->in_vlan[j].id = route->tuple[dir].in.vid[i];
 		flow_tuple->in_vlan[j].proto = route->tuple[dir].in.vproto[i];
--- a/net/netfilter/nft_flow_offload.c
+++ b/net/netfilter/nft_flow_offload.c
@@ -65,6 +65,7 @@ static int nft_dev_fill_forward_path(con
 
 struct nft_forward_info {
 	const struct net_device *dev;
+	__be16 pppoe_sid;
 	__u16 vid[NF_FLOW_TABLE_VLAN_MAX];
 	__be16 vproto[NF_FLOW_TABLE_VLAN_MAX];
 	struct {
@@ -101,6 +102,7 @@ static void nft_dev_path_info(const stru
 		case DEV_PATH_ETHERNET:
 		case DEV_PATH_DSA:
 		case DEV_PATH_VLAN:
+		case DEV_PATH_PPPOE:
 			info->dev = path->dev;
 			if (is_zero_ether_addr(info->h_source))
 				memcpy(info->h_source, path->dev->dev_addr, ETH_ALEN);
@@ -111,6 +113,9 @@ static void nft_dev_path_info(const stru
 				i = stack->num_paths;
 				break;
 			}
+			if (path->type == DEV_PATH_PPPOE) {
+				info->pppoe_sid = path->pppoe.sid;
+			}
 
 			/* DEV_PATH_VLAN */
 			if (info->num_vlans >= NF_FLOW_TABLE_VLAN_MAX) {
@@ -189,6 +194,7 @@ static void nft_dev_forward_path(struct
 		return;
 
 	route->tuple[!dir].in.ifindex = info.dev->ifindex;
+	route->tuple[!dir].in.pppoe_sid = info.pppoe_sid;
 	for (i = 0; i < info.num_vlans; i++) {
 		route->tuple[!dir].in.vid[i] = info.vid[i];
 		route->tuple[!dir].in.vproto[i] = info.vproto[i];
